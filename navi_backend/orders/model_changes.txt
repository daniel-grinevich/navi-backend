# Detailed Improvements for Customization System and Overall Robustness

## 1. Enhanced Customization Model Structure

The current customization system has several structural weaknesses. Here's a more robust design:

```python
class CustomizationGroup(StatusModel, UpdateRecordModel, AuditModel):
    name = models.CharField(_("Name"), max_length=200, db_index=True)
    description = models.CharField(_("Description"), max_length=255, blank=True)
    display_order = models.PositiveIntegerField(_("Display Order"), default=0)
    
    # Connect directly to menu items instead of categories
    menu_items = models.ManyToManyField(
        MenuItem, 
        through='MenuItemCustomizationGroup',
        related_name='customization_groups'
    )
    
    # Control how many selections can be made
    min_selections = models.PositiveIntegerField(
        _("Minimum Selections"), 
        default=0,
        help_text=_("Minimum number of options that must be selected")
    )
    max_selections = models.PositiveIntegerField(
        _("Maximum Selections"), 
        default=1,
        help_text=_("Maximum number of options that can be selected (0 = unlimited)")
    )
    
    is_required = models.BooleanField(_("Required"), default=False)
    
    class Meta:
        ordering = ['display_order', 'name']
        verbose_name = _("Customization Group")
        verbose_name_plural = _("Customization Groups")
        
    def clean(self):
        if self.min_selections > self.max_selections and self.max_selections > 0:
            raise ValidationError(_("Minimum selections cannot exceed maximum selections"))
```

## 2. Improved Customization Options

```python
class Customization(StatusModel, UpdateRecordModel, AuditModel):
    name = models.CharField(_("Name"), max_length=200, db_index=True)
    description = models.CharField(_("Description"), max_length=255, blank=True)
    group = models.ForeignKey(
        CustomizationGroup, 
        on_delete=models.CASCADE,
        related_name='options',
        verbose_name=_("Customization Group")
    )
    
    # Add pricing
    price_addition = models.DecimalField(
        _("Price Addition"),
        max_digits=8,
        decimal_places=2,
        default=Decimal('0.00'),
        validators=[MinValueValidator(Decimal('0.00'))],
        help_text=_("Additional price for this customization")
    )
    
    display_order = models.PositiveIntegerField(_("Display Order"), default=0)
    max_quantity = models.PositiveIntegerField(
        _("Maximum Quantity"),
        default=1,
        help_text=_("Maximum allowed quantity (0 = unlimited)")
    )
    
    # Common defaults
    is_default = models.BooleanField(
        _("Default Selection"), 
        default=False,
        help_text=_("Whether this option is selected by default")
    )
    
    class Meta:
        ordering = ['group', 'display_order', 'name']
        verbose_name = _("Customization Option")
        verbose_name_plural = _("Customization Options")
        indexes = [
            models.Index(fields=['group', 'display_order']),
            models.Index(fields=['is_default']),
        ]
    
    def clean(self):
        # Validate default selections against group rules
        if self.is_default and self.group.max_selections == 0:
            raise ValidationError(_("Cannot set default when no selections are allowed"))
```

## 3. Connecting Menu Items to Customization Groups

```python
class MenuItemCustomizationGroup(models.Model):
    menu_item = models.ForeignKey(MenuItem, on_delete=models.CASCADE)
    customization_group = models.ForeignKey(CustomizationGroup, on_delete=models.CASCADE)
    display_order = models.PositiveIntegerField(_("Display Order"), default=0)
    
    class Meta:
        unique_together = ('menu_item', 'customization_group')
        ordering = ['menu_item', 'display_order']
        verbose_name = _("Menu Item Customization Group")
        verbose_name_plural = _("Menu Item Customization Groups")
```

## 4. Improved OrderCustomization

```python
class OrderItemCustomization(UpdateRecordModel):
    order_item = models.ForeignKey(
        OrderItem, 
        on_delete=models.CASCADE,
        related_name='customizations'
    )
    customization = models.ForeignKey(
        Customization, 
        on_delete=models.PROTECT,
        related_name='order_usages'
    )
    quantity = models.PositiveIntegerField(_("Quantity"), default=1)
    unit_price = models.DecimalField(
        _("Unit Price"),
        max_digits=8,
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.00'))]
    )
    
    class Meta:
        verbose_name = _("Order Item Customization")
        verbose_name_plural = _("Order Item Customizations")
    
    def clean(self):
        max_qty = self.customization.max_quantity
        if max_qty > 0 and self.quantity > max_qty:
            raise ValidationError({
                'quantity': _("Maximum allowed quantity is %(max)s") % {'max': max_qty}
            })
    
    @property
    def subtotal(self):
        return self.quantity * self.unit_price
```

## 5. Add Order Validation and Processing Methods

```python
class Order(SlugifiedModel, StatusModel, UpdateRecordModel, AuditModel):
    # Existing fields with improvements
    user = models.ForeignKey(
        User, 
        on_delete=models.SET_NULL, 
        null=True, blank=True,
        related_name='orders'
    )
    payment_type = models.ForeignKey(
        PaymentType, 
        on_delete=models.SET_NULL, 
        null=True, blank=True,
        related_name='orders'
    )
    port = models.ForeignKey(
        Port, 
        on_delete=models.SET_NULL, 
        null=True, blank=True,
        related_name='orders'
    )
    total_price = models.DecimalField(  # renamed from totalPrice
        _("Total Price"),
        max_digits=10, 
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.00'))]
    )
    
    # New fields
    notes = models.TextField(_("Order Notes"), blank=True)
    customer_phone = models.CharField(_("Customer Phone"), max_length=20, blank=True)
    customer_email = models.EmailField(_("Customer Email"), blank=True)
    
    # Order state tracking
    is_paid = models.BooleanField(_("Is Paid"), default=False)
    paid_at = models.DateTimeField(_("Paid At"), null=True, blank=True)
    estimated_delivery_time = models.DateTimeField(
        _("Estimated Delivery Time"),
        null=True, blank=True
    )
    
    class Meta:
        verbose_name = _("Order")
        verbose_name_plural = _("Orders")
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['-created_at']),
            models.Index(fields=['status', '-created_at']),
            models.Index(fields=['is_paid']),
            models.Index(fields=['user']),
        ]
    
    def recalculate_total(self):
        """Recalculate the total price based on order items and their customizations."""
        subtotal = Decimal('0.00')
        for item in self.orderitem_set.all():
            subtotal += item.calculate_subtotal()
        self.total_price = subtotal
        return subtotal
    
    def mark_as_paid(self, payment_type=None):
        """Mark the order as paid."""
        if payment_type:
            self.payment_type = payment_type
        self.is_paid = True
        self.paid_at = timezone.now()
        self.save(update_fields=['is_paid', 'paid_at', 'payment_type', 'updated_at'])
    
    def validate_customizations(self):
        """Validate that all required customization groups have selections."""
        errors = []
        for item in self.orderitem_set.all():
            item_errors = item.validate_customizations()
            if item_errors:
                errors.append({
                    'item': item.menu_item.name,
                    'errors': item_errors
                })
        return errors
```

## 6. Improved OrderItem with Customization Support

```python
class OrderItem(StatusModel, UpdateRecordModel, AuditModel):
    order = models.ForeignKey(
        Order, 
        on_delete=models.CASCADE,
        related_name='items'
    )
    menu_item = models.ForeignKey(
        MenuItem, 
        on_delete=models.PROTECT,  # Changed from SET_NULL to PROTECT
        related_name='order_usages'
    )
    quantity = models.PositiveIntegerField(  # renamed from qty
        _("Quantity"), 
        default=1,
        validators=[MinValueValidator(1)]
    )
    unit_price = models.DecimalField(  # renamed from price
        _("Unit Price"),
        max_digits=8, 
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.01'))]
    )
    special_instructions = models.TextField(_("Special Instructions"), blank=True)
    
    class Meta:
        verbose_name = _("Order Item")
        verbose_name_plural = _("Order Items")
    
    def __str__(self):
        return f"{self.quantity}x {self.menu_item.name}"
    
    def calculate_subtotal(self):
        """Calculate subtotal including customizations."""
        base_subtotal = self.quantity * self.unit_price
        customization_total = sum(
            c.subtotal for c in self.customizations.all()
        )
        return base_subtotal + customization_total
    
    def validate_customizations(self):
        """Validate that required customization groups have selections."""
        errors = []
        
        # Get all required customization groups for this menu item
        required_groups = self.menu_item.customization_groups.filter(
            is_required=True,
            menuitemcustomizationgroup__menu_item=self.menu_item
        )
        
        # Check existing customizations
        selected_groups = set()
        for customization in self.customizations.all():
            group = customization.customization.group
            selected_groups.add(group.id)
            
            # Validate quantity against group rules
            if group.max_selections > 0:
                group_selections = self.customizations.filter(
                    customization__group=group
                ).count()
                if group_selections > group.max_selections:
                    errors.append(f"Too many selections for {group.name}")
        
        # Check for missing required groups
        for group in required_groups:
            if group.id not in selected_groups:
                errors.append(f"Missing required selection for {group.name}")
                
        return errors
```

## 7. Manager Methods for Common Operations

Add to `MenuItem`:

```python
class MenuItem(SlugifiedModel, StatusModel, UpdateRecordModel, AuditModel):
    # ... existing fields ...
    
    def get_available_customizations(self):
        """Get all active customization groups and their options for this menu item."""
        return self.customization_groups.filter(
            status=self.Status.ACTIVE,
            is_deleted=False,
            menuitemcustomizationgroup__menu_item=self
        ).prefetch_related(
            'options'
        ).order_by(
            'menuitemcustomizationgroup__display_order'
        )
    
    def get_default_customizations(self):
        """Get default customizations for this menu item."""
        return Customization.objects.filter(
            group__menu_items=self,
            is_default=True,
            status=self.Status.ACTIVE,
            is_deleted=False
        )
```

## 8. Improved Caching Strategy

Add to `CustomizationGroup`:

```python
def get_cache_key(self):
    return f"customization_group:{self.id}:v{self.version}"

def invalidate_cache(self):
    """Invalidate cache for this customization group and related menu items."""
    cache_keys = [self.get_cache_key()]
    
    # Invalidate all related menu items
    for menu_item in self.menu_items.all():
        menu_item.invalidate_cache()
    
    cache.delete_many(cache_keys)
```

## 9. Optimization for Bulk Operations

Add a custom manager for OrderItemCustomization:

```python
class OrderItemCustomizationManager(models.Manager):
    def bulk_create_from_defaults(self, order_item):
        """Create default customizations for a new order item."""
        defaults = order_item.menu_item.get_default_customizations()
        customizations = []
        
        for default in defaults:
            customizations.append(OrderItemCustomization(
                order_item=order_item,
                customization=default,
                quantity=1,
                unit_price=default.price_addition
            ))
        
        return self.bulk_create(customizations)
```

These improvements make the customization system more robust, flexible, and performance-oriented while maintaining a clean design and proper validation.